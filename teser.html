<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Cybergeometry</title>
    <script>
        codes = [`////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////// HELP /////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// Click the object to control with the mouse.                                //
// Press escape to release.                                                   //
// Right click to move.                                                       //
// Click and drag horizontally to change the axes of rotation.                //
// Pressing ctrl-enter attempts to run the script diplayed here.              //
//                                                                            //
// The code here must create a function points to generate n-dimensional      //
// points, a function edges that produces an array of pairs of indices into   //
//  points. The function must also include a function edgeColors, with an rgb //
// array for each edge, or a function pointColors, for per-vertex coloring.   //
// An optional function, runOnce, may be included with a initialization       //
// routine.                                                                   //
//                                                                            //
// Available functions:                                                       //
//   hsv2rgb( h, s, v )                                                       //
//     Takes a hue between 0 and 360, and a saturation and value              //
//     between 0 and 1, and converts it into a 3 element rgb array            //
//   shl( x, hightbit )                                                       //
//     This returns x shifted left one bit (i.e. divided by two),             //
//     and adds highbit if the low bit was set.                               //
//   log( msg )                                                               //
//     It's better than bad, it's good! msg may contain html.                 //
//                                                                            //
// Uncomment these lines to get a list of variables accesible                 //
// through prmtr.
// { let s = ""; for(const o in prmtr) 
//                 s += 'prmtr.' + o + ' = ' + prmtr[o] + '<br>'; 
//   log(s); }
//                                                                            //
// You can add extra parameters like this   â†“                                 //
////////////////////////////////////////////////////////////////////////////////
prmtr.add({displayFunc:(v => "Saturation: " + v), name: "sat", min: 0, max: 1,
           default: 0.5, step: 0.01}); 
// A boolean option
prmtr.add({name: "diag", label: "Diagonals", default: false})

// r generates the points of a cybercube
let q = (v, l) => l.map((i) => i.concat([v]));
let r = (n, l) => n ? r(n - 1, q(-1, l).concat(q(1, l))) : l
points = r(prmtr.dim, [[]]);


// edges contains indices into points
edges = [];
for (let i = 0; i < points.length / 2; ++i) {
    let x = i * 2;
    let y = x + 1;
    for (let d = 0; d < prmtr.dim; d++) {
        let p = [x, y];
        p = p.concat(hsv2rgb((d / prmtr.dim + 12) * 360, prmtr.sat, 1));
        edges.push(p);
        x = shl(x); y = shl(y);
    }
}`,
            `prmtr.add({displayFunc:(v => "Saturation: " + v), name: "sat",
          min: 0,   max: 1,   default: 0.5,     step: 0.01});            
prmtr.add({displayFunc:(v => "Circle segments: " + v), name: "circleSegs",
          min: 3,   max: 64,   default: 16,     step: 1});            
prmtr.add({displayFunc:(v => "Slices: " + v), name: "slices",
          min: 1,   max: 20,   default: 3,     step: 1});        

for( let i = 0; i < prmtr.circleSegs; ++i ){
  
  points.push( [Math.sin(2*Math.PI*i/prmtr.circleSegs),
                Math.cos(2*Math.PI*i/prmtr.circleSegs)] );
  edges.push( [i,(i+1)%prmtr.circleSegs] );
}



let newPoints = [];
let newEdges = [];
points.forEach(e=>{while(e.length < prmtr.dim)e.push(0)});

for( let d = 2; d < prmtr.dim; ++d ){
  for( let i = 0; i < prmtr.slices; ++i ){
    let r = 2 * (i+0.5) / prmtr.slices - 1;
    let sc = Math.sqrt( 1 - r*r );
    newPoints = newPoints.concat( points.map( e => (e.map( (f, h) => (h == d ? r : sc*f)))));
    newEdges = newEdges.concat( edges.map( e => (e.map( f => f + newEdges.length ))));
  }
}

function rotate( a ){
  let b = a.slice();
  b.push( b.shift() );
  return b;
}


if( newEdges.length ){
  edges = newEdges; points = newPoints;
  newPoints = []; newEdges = [];
  for( let i = 0; i < prmtr.dim; ++i ){
    newPoints = newPoints.concat( points );
    points = points.map( e => rotate( e ) );
    newEdges = newEdges.concat( edges.map( e => ([...e.map( f => f + newEdges.length ),...hsv2rgb(i * 360 / prmtr.dim,prmtr.sat,1)])));
  }
  edges = newEdges; points = newPoints;
} else 
edges.forEach(e=>{while(e.length < 5)e.push(255)});`,
            `
prmtr.add({displayFunc:(v => "Saturation: " + v), name: "sat",
          min: 0, max: 1, default: 0.5, step: 0.01});            
prmtr.add({displayFunc:(v => "Grid segments: " + v), name: "gridSegs",
          min: 3, max: 16, default: 4, step: 1});            

let s = prmtr.gridSegs;
let nedges = [];
let npoints = points = [...Array(s).keys()].map( e => [e * 2 / (s-1) - 1] );
edges = [[0,s-1]];
for( let d = 1; d < prmtr.dim; ++d ){ 
  npoints = npoints.flatMap( e => points.map( f => e.concat( f )));
  edges = [...Array(s).keys()].flatMap( e => edges.map( f => f.map( g => g + e*s*edges.length )))

}

let fmod = x => Math.floor( x / s ) + ( x % s ) * ( s ** (prmtr.dim -1));
nedges = [];
for( let d = 0; d < prmtr.dim; ++d ){ 
  nedges = nedges.concat(edges.map( e => e.concat( hsv2rgb(d * 360 / prmtr.dim,prmtr.sat,1))));
  edges = edges.map( (e,k) => [fmod(e[0]),fmod(e[1])]);
}
edges = nedges;
points = npoints;
`,
            `prmtr.add({displayFunc:(v => "Saturation: " + v), name: "sat",
          min: 0, max: 1, default: 0.5, step: 0.01});            
prmtr.add({displayFunc:(v => "Circle segments: " + v), name: "circleSegs",
          min: 3, max: 64, default: 4, step: 1});            

let sdim = Math.floor( (prmtr.dim + 1 ) / 2 );
let even = prmtr.dim % 2 == 0;
for( let i = 0; i < sdim; ++i )
  prmtr.add({displayFunc:(v => "Radius " + i + ": " + v), name: "rad" + i,
           min: 0, max: 2, default: (i+1) / sdim, step: 0.001}, true);

let s = prmtr.circleSegs;
let nedges = [];
let npoints = points = [...Array(s).keys()].map( e => [e * 2 / (s) - 1] );
edges = [...Array(s).keys()].map( e => [e, (e+1) % s] );
for( let d = 1; d < sdim; ++d ){ 
  npoints = npoints.flatMap( e => points.map( f => e.concat( f )));
  nedges = [...Array(s).keys()].flatMap( e => edges.map( f => f.map( g => g + e*edges.length )))
  edges = nedges.map( f => [f[0],(f[0]+edges.length)%nedges.length] );

}
let fmod = x => Math.floor( x / s ) + ( x % s ) * ( s ** (sdim -1));
nedges = [];
for( let d = 0; d < sdim; ++d ){ 
  nedges = nedges.concat(edges.map( e => e.concat( hsv2rgb(d * 360 / prmtr.dim,prmtr.sat,1))));
  edges = edges.map( (e,k) => [fmod(e[0]),fmod(e[1])]);
}
edges = nedges;
points = npoints;

let str = "";
points = points.map( element => 
  element.flatMap( (e,k) => {
    let r = prmtr["rad"+k];
    return even || k < sdim - 1 ? [r*Math.sin(Math.PI*e),r*Math.cos(Math.PI*e)] : [e];
  })
);

if( !even )
  points = points.map( element => {
    let r = prmtr["rad"+(sdim-1)];
    let r2 = prmtr["rad"+(sdim-2)];
    return element.map( (e,k) => {
      let le = Math.PI * element[ element.length - 1 ];
      return (k == prmtr.dim-1 ? r * r2 * Math.sin( le ) : e * ( r2 + r * Math.cos( le ) ) );
    });
  });`
        ];
        let points = [];
        let edges = [];
        let params = [];
        let center = [[0]];
        let scale = 1;
        function shl(x, highBit) {
            let b = x & 1;
            x >>= 1;
            if (b)
                x += points.length / 2;
            return x;
        }
        function hsv2rgb(h, s, v) {
            function f(n) {
                let k = (n + h / 60) % 6;
                return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
            }
            return [Math.floor(f(5) * 256), Math.floor(f(3) * 256), Math.floor(f(1) * 256)];
        }
    </script>
    <style>
        html {
            --border: #87FFDD;
            --borderWidth: 1px;
            --control: #87E4FF;
            --editBorder: #87ffb5;
            --editbg: #171717;
            --editfg: #ffe5e5;
            --controlBackground: #FFFFFF;
            --errorColor: #FF0000;
            --bg: #000000;
            --fg: #FFFFFF;

            background-color: var(--bg);
            color: var(--fg);
            font-family: sans-serif;
        }

        .prmtr {
            -webkit-appearance: none;
            -webkit-transition: .2s;
            appearance: none;
            height: 0.75em;
            background: var(--controlBackground);
            outline: none;
            opacity: 0.8;
            transition: opacity .05s;
            display: inline;
            float: right;
            width: 60%;
        }

        .prmtr:hover {
            opacity: 1;
        }

        .prmtr::-webkit-prmtr-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 1.25em;
            height: 1.25em;
            background: var(--control);
            transition: background-color 0.05s;
            border-width: 0px;
            cursor: pointer;
            outline: none;
        }

        .prmtr::-moz-range-thumb {
            width: 1.5em;
            height: 1.5em;
            background: var(--control);
            transition: background-color 0.05s;
            cursor: pointer;
            outline: none;
        }

        .prmtr::-moz-range-thumb:hover {
            background: #ffffff;
        }

        .control {
            padding-bottom: 0.5em;
            font-weight: bolder;
            border: 0%;
        }


        #cbbar {
            width: 100%;
            padding-bottom: 0.5em;
        }

        .cbcontrol {
            font-size: small;
            padding-left: 1em;
        }

        #panel {
            border-style: solid;
            border-width: var(--borderWidth);
            border-color: var(--border);
            box-sizing: border-box;
            padding: 0.5em;
            float: right;
            flex-flow: column;
            display: flex;
        }

        #c {
            border-style: solid;
            border-width: var(--borderWidth);
            border-color: var(--border);
            box-sizing: border-box;
            float: left;
        }


        #edit {
            resize: none;
            box-sizing: border-box;
            width: 100%;
            margin-top: 1em;
            background-color: var(--editbg);
            color: var(--editfg);
            flex: 1 1 auto;
            font-family: monospace;
        }

        select {
            color: var(--fg);
            background-color: var(--bg);
        }

        #message {
            font-family: monospaced;

        }
    </style>
</head>

<body>

    <canvas id="c" width="100%" height="100%"></canvas>
    <div id="panel"></div>
    <script>
        let axes = [];
        let axesCombos = [];
        let rotations = [];
        let axesIndices = [];
        function redim(v) {
            if (!v)
                v = prmtr.dim;
            let combine = (a) => a.flatMap((e, i) => a.filter((f, j) => j > i).map(g => [e, g]));
            axes = combine([...Array(v).keys()]);
            axesCombos = combine(axes);
            axesIndices = combine([...axes.keys()]);
            while (rotations.length < axes.length)
                rotations.push(0);
            while (rotations.length > axes.length)
                rotations.pop();
            if (document.getElementById("rotAxes")) {
                document.getElementById("rotAxes").max = axesCombos.length - 1;
                upd("rotAxes", 0);
            }
            run();
        }
        function axisname(x) {

            if (prmtr.dim == 2 || axesCombos.length == 0) {
                return "xy";
            } else {
                const axisString = "xyzwuvtsrqponmlkjihgfedcba";
                return axisString.substr(axesCombos[x][0][0], 1) + axisString.substr(axesCombos[x][0][1], 1) + "," + axisString.substr(axesCombos[x][1][0], 1) + axisString.substr(axesCombos[x][1][1], 1);
            }
        }
        let presetParams = {
            'dim': [v => "Dimension: " + v, 2, 8, 4, 1],
            'lineWidth': [v => "Line width: " + v, 0.01, 5, 1, 0.001],
            'dist': [v => "Distance: " + v, 1, 5, 1.5, 0.001],
            'zoom': [v => "Zoom: " + v, 0, 2, 1, 0.001],
            'segments': [v => "Line segments: " + v, 1, 10, 1, 1],
            'rotSpeed': [v => "Rotation speed: " + v, 0, 5, 1, 0.1],
            'rotAxes': [v => "Rotation axes: " + axisname(parseFloat(v), 4), 0, 0, 1, 1],
            'autoRot': ["Autorotate", true],
            'occlusion': ["Occlusion", true],
        }
        let prmtr = {}
        Object.keys(presetParams).forEach(e => {
            if (presetParams[e].length == 2)
                prmtr[e + "val"] = presetParams[e][1];
            else
                prmtr[e + "val"] = presetParams[e][3];
            Object.defineProperty(prmtr, e, {
                set: f => {
                    prmtr[e + "val"] = f;
                    upd(e, f);
                },
                get: () => prmtr[e + "val"]
            });
        });
        function upd(id, value, controled) {
            if (document.getElementById(id).type == "checkbox") {
                if (!controled)
                    document.getElementById(id).checked = value;
                prmtr[id + "val"] = value;
            } else {
                let nv = parseFloat(value);
                ov = prmtr.dim;
                prmtr[id + "val"] = nv;
                document.getElementById(id + 'Label').innerHTML = (presetParams[id] ? presetParams[id] : params[id])[0](nv);
                if (!controled) {
                    document.getElementById(id).value = value;
                }
                if (id == "dim" && ov != nv) {
                    redim(nv);
                }
            }
            if (params[id]) {
                run(true);
            }
        }

        let s = "";
        function genControl(i, pars) {
            let e = pars[i];
            if (e.length == 2) {
                return '<span class="cbcontrol" id="' + i + "div" + '"><label id="' + i + 'Label" class="left" for="' + i + '">' + e[0] + '</label>' +
                    '<input oninput="upd(' + "'" + i + "'," + 'this.checked,true)" id="' + i + '"type="checkbox" checked="' + e[1] + '"></span>';
            } else
                return '<div class="control" id="' + i + "div" + '"><label id="' + i + 'Label" class="left" for="' + i + '">' + e[0](prmtr[i]) + '</label>' +
                    '<input oninput="upd(' + "'" + i + "'," + 'this.value,true)" id="' + i + '"type="range" min="' + e[1] + '"" max="' + e[2] + '" value="' + prmtr[i] + '" step="' + e[4] + '"class="prmtr"></div>';
        }
        function repanel() {
            let code = document.getElementById("edit");
            let s = ""; let q = "";
            Object.keys(presetParams).forEach(i => {
                if (presetParams[i].length == 2)
                    q += genControl(i, presetParams);
                else
                    s += genControl(i, presetParams);
            });
            s += '<div id="customParameters"></div><div id="cbbar"><span id="presetCheckboxes">' + q +
                '</span><span id="customCheckboxes"></span></div><div>' +
                '<label for="codeSelect">Code:</label>' +
                '<select name="codes" id = "codeSelect" >' +
                '<option value="0">Cybercube</option>' +
                '<option value="1">Cybersphere</option>' +
                '<option value="2">Cybergrid</option>' +
                '<option value="3">Cybertorus</option>' +
                '</select></div>';
            s += '<textarea style="white-space: pre;" rows="20" cols="80" spellcheck="false" id="edit"></textarea><p id="message"></p>'
            let tv = document.getElementById("codeSelect") ? document.getElementById("codeSelect").value : 0;
            document.getElementById("panel").innerHTML = s;
            document.getElementById("codeSelect").value = tv;

            document.getElementById("edit").value = code ? code.value : codes[0];


            document.getElementById("codeSelect").onchange = ev => {
                document.getElementById("edit").value = codes[ev.target.value];
                run();
            }
            document.onkeydown = ev => {
                if (ev.key == "Enter" && ev.ctrlKey) {
                    run();
                }
            }
            redim();
        }
        function log(v) {
            document.getElementById("message").style.display = 'block';
            document.getElementById("message").innerHTML = v;
            if (document.getElementById("message").innerHTML == "")
                document.getElementById("message").style.display = 'none';
        }
        function addParam(o, reset) {
            if (prmtr[o.name + "val"] == null) {
                prmtr[o.name + "val"] = o.default;
                Object.defineProperty(prmtr, o.name, {
                    set: f => {
                        prmtr[o.name + "val"] = f;
                        upd(o.name, f);
                    },
                    get: () => prmtr[o.name + "val"]
                })
            }
            if (o.label) {
                params[o.name] = [o.label, o.default];
                if (!document.getElementById(o.name + "div"))
                    document.getElementById("customCheckboxes").innerHTML += genControl(o.name, params);
            } else {
                params[o.name] = [o.displayFunc, o.min, o.max, o.default, o.step];
                if (!document.getElementById(o.name + "div"))
                    document.getElementById("customParameters").innerHTML += genControl(o.name, params);
            }
            if (reset)
                prmtr[o.name] = o.default;

        }
        function errmsg(err) {
            if (err.type == "SyntaxError") {
                let ls = document.getElementById("edit").value.split(/\r?\n/);
                let l = ls[err.lineNumber];
                let l1 = (ls[err.lineNumber - 1] ? ls[err.lineNumber - 1] : "") + "\n" + l.substr(0, err.columnNumber);
                let l2 = l.substr(err.columnNumber) + "\n" + (ls[err.lineNumber + 1] ? ls[err.lineNumber + 1] : "");

                log("<span style='color: var(--errorColor)'>Error! " + err.lineNumber + ":" + err.columnNumber + "</span><br><br><code style='white-space: pre-line;'>" +
                    "<span id='errmsgL1'></span><span style='color: var(--errorColor)'>-->error here<--</span><span id='errmsgL2'></span>" +
                    "</span><br><br><span style='color: var(--errorColor)'><span id='errmsgMessage'></span>\n\nStack:\n<span id='errmsgStack'></span></span></code>");
                document.getElementById("errmsgMessage").innerText = err.message;
                document.getElementById("errmsgStack").innerText = err.stack;
                document.getElementById("errmsgL1").innerText = l1;
                document.getElementById("errmsgL2").innerText = l2;
            } else
                alert("Unknown error!\n" + err.toString());

        }
        prmtr.add = addParam;
        function run(noparams) {
            let oparams = params;
            if (!noparams)
                params = [];
            else
                prmtr.add = (e, f) => true;
            points = [];
            edges = [];
            try {
                log("");
                let create = Function(document.getElementById("edit").value);
                create();
                center = points.reduce((v, nv) => v.map((e, k) => e + nv[k]));
                scale = Math.sqrt(Math.max(...points.map(v => v.reduce((v2, nv2) => v2 + (nv2 * nv2), 0))));
                points = points.map(e => e.map(f => f / scale));
            } catch (err) {
                errmsg(err);
            }
            if (!noparams) {
                for (i in oparams)
                    if (!params[i])
                        document.getElementById(i + "div").remove();
            } else
                prmtr.add = addParam;
        }
        repanel();

    </script>
</body>

<script>
    let c = document.getElementById('c');;
    let x = c.getContext('2d');

    function resize() {
        let dw = document.body.clientWidth || 400;
        let dh = document.documentElement.clientHeight - 20 || 400; // wtf does this -20 come from?
        if (dw > dh) {
            dw = dw * 0.5 - 5;
            document.getElementById("panel").style.height = dh + "px";
            document.getElementById("panel").style.float = "right";
            document.getElementById("c").style.marginBottom = "0px";
            document.documentElement.style.overflow = 'hidden';
        } else {
            dh = dw;
            document.getElementById("panel").style.height = "auto";
            document.getElementById("panel").style.float = "left";
            document.getElementById("c").style.marginBottom = "10px";
            document.documentElement.style.overflow = 'auto';
        }
        document.getElementById("panel").style.width = dw + "px";
        c.style.width = dw + "px";
        c.style.height = dh + "px";
        c.width = c.clientWidth;
        c.height = c.clientHeight;
    }
    window.onresize = resize;
    resize();
    let axesHandle = 0;
    function rclickListener(ev) {
        ev.preventDefault();
        return false;
    }
    c.addEventListener('contextmenu', rclickListener, false);
    {
        let lastbuttons = 0;
        c.onclick = c.ondblclick = c.onmousemove = c.onmousedown = c.onmouseup = (ev) => {
            if (document.pointerLockElement) {
                let mdim = Math.sqrt(c.width * c.width + c.height * c.height);
                let mx = ev.movementX * 0.003;
                let my = ev.movementY * 0.003;
                if (ev.buttons & 2)
                    document.exitPointerLock();
                if (ev.buttons & 1) {
                    if (prmtr.dim > 2) {
                        axesHandle = (axesHandle + mx * axesCombos.length) % axesCombos.length + axesCombos.length;
                        upd("rotAxes", Math.floor(axesHandle - axesCombos.length) + "");
                    }
                } else {
                    let ai = axesIndices[prmtr.rotAxes] || [0, 0];
                    rotations[ai[0]] += mx;
                    rotations[ai[1]] += my;
                }
            } else if (lastbuttons & 1 && ev.type == "mouseup")
                c.requestPointerLock();
            lastbuttons = ev.buttons;
        }
    }
    function u(time, delta) {
        x.clearRect(0, 0, c.width, c.height);
        let scaleDim = Math.sqrt(c.width * c.width + c.height * c.height) / Math.sqrt(2);
        let mzoom = 0.06 * (2 ** (prmtr.zoom * prmtr.dim));

        let dd = l => l.map(i => i.map((v) => v / (i[0] + prmtr.dist))).map((i) => (i.shift(), i));
        let rot = (l, t, a1, a2) => l.map((i) => i.map((v, j) => (j == a1 ? v * Math.cos(t) + i[a2] * Math.sin(t) : (j == a2 ? v * Math.cos(t) - i[a1] * Math.sin(t) : v))))

        if (!document.pointerLockElement && prmtr.autoRot)
            rotations = rotations.map((e, i) => e + delta * prmtr.rotSpeed * (4 / (i + 5)));

        let d = [];
        let widths = [];
        let p = points.map(e => e.slice()).slice();
        rotations.forEach((e, i) => {
            p = rot(p, e, axes[i][0], axes[i][1]);
        });

        let e = edges;
        if (p[0]) {
            while (p[0].length > 3)
                p = dd(p);
            if (p[0].length == 3) {
                widths = p.map((i) => 10 * prmtr.lineWidth / (i[0] + prmtr.dist))
                if (prmtr.occlusion)
                    e = edges.sort((v1, v2) => (p[v2[0]][0] + p[v2[1]][0]) - (p[v1[0]][0] + p[v1[1]][0]));
                p = dd(p);
            } else
                widths = p.map((i) => prmtr.lineWidth);
            d = p.map((i) => (i.map((j) => j * 0.5 * mzoom)));
        }



        let i = 0;
        while (e[i]) {
            let ox = c.width / 2;
            let oy = c.height / 2;
            let s = prmtr.segments;
            let xb = d[edges[i][0]][0] * scaleDim + ox;
            let yb = d[edges[i][0]][1] * scaleDim + oy;
            let wb = widths[edges[i][0]];
            let xs = d[edges[i][1]][0] * scaleDim + ox - xb;
            let ys = d[edges[i][1]][1] * scaleDim + oy - yb;
            let ws = widths[edges[i][1]] - wb;
            x.moveTo(xb, yb);
            x.strokeStyle = 'rgb(' + edges[i][2] + ',' + edges[i][3] + ',' + edges[i][4] + ')';
            x.beginPath();
            for (s = 0; s <= prmtr.segments; ++s) {
                let sc = 1 - (s / prmtr.segments);
                x.lineWidth = wb + sc * ws;
                x.lineTo(xb + sc * xs, yb + sc * ys);
                x.stroke();

            }
            i++;
        }

    }
    let ot = (new Date()).getTime() / 1000;
    function l() {
        let t = (new Date()).getTime() / 1000;
        dt = t - ot;
        u(t, dt);
        ot = t;
        requestAnimationFrame(l);
    }
    requestAnimationFrame(l);
</script>

</html>